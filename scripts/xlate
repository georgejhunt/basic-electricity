#!/bin/env python
# -*- coding: utf-8 -*-
# use (or create) Portable Objecet Template to localize *.sml file 
# input parameters <full path of sml file> <volume> <language>

import sys, os
#from google.cloud import translate
from googleapiclient.discovery import build

import yaml
import codecs

cwd = os.getcwd()
liec_dir = os.environ["BE_LIEC_DIR"]
be_dir = os.environ["BE_DIR"]

# individual google cloud authentication seem easiest (first $300 of service is free)
API_KEY = os.environ["BE_API_KEY"]
service = build('translate', 'v2', developerKey=API_KEY)

def gtranslate(text,slang='en',tlang='es'):
    return service.translations().list(
           source=slang, 
           target=tlang,
           q=[text]
           ).execute()

if len(sys.argv) < 3:
  print "input parameters <full path of sml file> <volume> <language>"
  sys.exit(1)

# split apart identifier from full path
basename = os.path.basename(sys.argv[1])

# volume is second parameter
volume = sys.argv[2]

# target language is third parameter
tlang = sys.argv[3]

# Look to see if we already have translation going for this sml file
inputFilename = be_dir + '/po-templates/' + basename +'.pot.' + tlang
try: # to load the portable object translation file
   fd = codecs.open(inputFilename,"r","utf-8")
   po = yaml.load(fd)
except:
   po = {}
fd.close()
   
# open the english SubML source file
fd = open (sys.argv[1],"r")
raw = fd.read()
fd.close()

tags = [ [ '<para>\n', '</para>\n' ], ]
rawmap = []
dict_changed = False

# iterate over the tag types that must be translated
for j in range(len(tags)):
    tag,tagend = tags[j]
    index = 0
    num_nibbles = 0

    while index < len(raw) and index != len(tag)-1:
         index = raw.find(tag,index) + len(tag)
         if index != len(tag)-1:
            endnibble = raw.find(tagend,index) 
            if endnibble != -1:
               english_text = (raw[index:endnibble])
               if not english_text in po.keys():
                  tr = gtranslate(english_text)
                  asciistr = tr['translations'][0]['translatedText']
                  po[english_text] = {"xlate":asciistr, "tag":tag}
                  dict_changed = True
               else:
                   asciistr = po[english_text]['xlate']
               # record the starting index, and end
               rawmap.append([ index, endnibble ])
               index = endnibble + len(tagend) + 1
               num_nibbles += 1

# now reread the input string, and assemble the outstr
index = 0

# rewrite the .pot file if any changes
if dict_changed:
    fd = codecs.open(inputFilename,"w","utf-8")
    yaml.dump(po,fd,allow_unicode=True)
    fd.close()

# use sorted rawmap as indexes into the raw input that need substitution
rawmap.sort()
print rawmap
outstr = u''
for startnibble, endnibble in rawmap:
    outstr += raw[index:startnibble]
    dictkey = raw[startnibble:endnibble]
    outstr += po[dictkey]['xlate']
    index = endnibble
    

# now write out the translated sml file
outFile = liec_dir + '/build/'+ tlang + '/' + volume + '/'+ basename 
fd = codecs.open(outFile,"w","utf-8")
fd.write(outstr)
fd.close()
print(num_nibbles)
